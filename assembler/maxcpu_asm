#!/usr/bin/env ruby

require 'optparse'

### Class definitions

class Jump
  attr_accessor :label

  def initialize(label)
    @label = label
  end
end

class Instruction
  attr_accessor :label, :command, :attributes

  OP_CODES = {'nop' => [0, 0], 'stop' => [1, 0], 'add' => [2, 0], 'addc' => [3, 0], 'sub' => [4, 0], 'subc' => [5, 0],
              'not' => [6, 0], 'and' => [7, 0], 'or' => [8, 0], 'xor' => [9, 0], 'rea' => [10, 0], 'reo' => [11, 0],
              'rex' => [12, 0], 'sll' => [13, 0], 'srl' => [14, 0], 'sra' => [15, 0], 'rol' => [16, 0],
              'rolc' => [17, 0], 'ror' => [18, 0], 'rorc' => [19, 0], 'ldc' => [32, 1], 'ldd' => [33, 1],
              'ldr' => [34, 0], 'std' => [35, 1], 'str' => [36, 0], 'in' => [37, 0], 'out' => [38, 0],
              'ldpc' => [39, 0], 'stpc' => [40, 0], 'jmp' => [48, 1], 'jz' => [49, 1], 'jc' => [50, 1], 'jn' => [51, 1],
              'jo' => [52, 1], 'jnz' => [53, 1], 'jnc' => [54, 1], 'jnn' => [55, 1], 'jno' => [56, 1]}

  ASSEMBLY_PARSER = %r{
                       ^
                         ((?<label>[^\n]*):)?
                         ([^\S\n]*(?<command>[a-zA-Z]{1,4}))?
                         ([^\S\n]+(?<attr_1>[^\s;\n]+))?
                         ([^\S\n]+(?<attr_2>[^\s;\n]+))?
                         ([^\S\n]+(?<attr_3>[^\s;\n]+))?
                         ([^\S\n]*;[^\S\n]*(?<comment>[^\n]*))?
                       $}x

  private

  def parse_twos_complement(num, bits)
    num &= (2 << bits - 1) - 1 # Mask
    ("%0#{bits}b" % Integer(num)).to_i(2)
  end

  def parse_attr(attribute)
    return nil if attribute.nil?
    return Integer('0x' + attribute[1..-1]) if attribute =~ /^#/
    return Integer(attribute[1..-1]) if attribute =~ /^R/i
    return parse_twos_complement(Integer(attribute), 12) rescue Jump.new(attribute)
  end
end


### Helpers

def puts_err(err, line_nr = nil)
  STDERR.puts "ERROR:#{(' Line ' + line_nr.to_s + ':') if !line_nr.nil?} #{err}"
  exit
end


### Program options

options = {}
OptionParser.new do |opts|
  opts.banner = 'Usage: maxcpu_asm [-o outfile] [options] filename'

  opts.on('-oPATH', '--outfile=PATH', 'Path to output file') do |path|
    options[:outfile] = path
  end

  opts.on_tail('-h', '--help', 'Prints this help') do
    puts opts
    exit
  end
end.parse!
